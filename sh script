#!/bin/bash

# Script: caapi_log_analyzer_dynamic.sh
# Description: Analyze CAAPI logs for specific URLs and time ranges

# Default values
LOG_FILE=""
SHOW_TOP=20
SHOW_SUMMARY=true
COLOR_OUTPUT=true

# Arrays to store multiple URLs and time ranges
declare -a URL_PATTERNS
declare -a TIME_RANGES

# Colors for terminal output
if [ "$COLOR_OUTPUT" = true ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    PURPLE='\033[0;35m'
    NC='\033[0m' # No Color
else
    RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; PURPLE=''; NC=''
fi

# Function to display usage
usage() {
    echo "Usage: $0 -f <log_file> [OPTIONS]"
    echo ""
    echo "Required:"
    echo "  -f  Log file to analyze"
    echo ""
    echo "Options:"
    echo "  -u <url_pattern>        URL pattern to filter (can be used multiple times)"
    echo "  -t <start_hour-end_hour> Time range (e.g., 10-11, 12-13)"
    echo "  -n <number>             Number of top results to show (default: 20)"
    echo "  --no-color              Disable colored output"
    echo "  --no-summary            Disable summary display"
    echo "  -h                      Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -f access.log -u \"uploaddocument\" -t 10-11"
    echo "  $0 -f access.log -u \"downloaddocument\" -t 12-13"
    echo "  $0 -f access.log -u \"uploaddocument\" -u \"downloaddocument\" -t 10-11 -t 12-13"
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f) LOG_FILE="$2"; shift 2 ;;
        -u) URL_PATTERNS+=("$2"); shift 2 ;;
        -t) TIME_RANGES+=("$2"); shift 2 ;;
        -n) SHOW_TOP="$2"; shift 2 ;;
        --no-color) COLOR_OUTPUT=false; shift ;;
        --no-summary) SHOW_SUMMARY=false; shift ;;
        -h) usage ;;
        *) echo "Unknown option: $1"; usage ;;
    esac
done

# Validate required parameters
if [[ -z "$LOG_FILE" ]]; then
    echo -e "${RED}Error: Log file is required${NC}"
    usage
fi

if [[ ! -f "$LOG_FILE" ]]; then
    echo -e "${RED}Error: Log file '$LOG_FILE' not found${NC}"
    exit 1
fi

if [[ ${#URL_PATTERNS[@]} -eq 0 ]]; then
    echo -e "${YELLOW}Warning: No URL patterns specified. Analyzing all URLs.${NC}"
    URL_PATTERNS=(".*")
fi

if [[ ${#TIME_RANGES[@]} -eq 0 ]]; then
    echo -e "${YELLOW}Warning: No time ranges specified. Analyzing all hours.${NC}"
    TIME_RANGES=("0-23")
fi

echo -e "${CYAN}=== CAAPI Log Analyzer ===${NC}"
echo -e "${BLUE}Log file:${NC} $LOG_FILE"
echo -e "${BLUE}File size:${NC} $(du -h "$LOG_FILE" | cut -f1)"
echo -e "${BLUE}Lines:${NC} $(wc -l < "$LOG_FILE")"
echo -e "${BLUE}URL patterns:${NC} ${URL_PATTERNS[*]}"
echo -e "${BLUE}Time ranges:${NC} ${TIME_RANGES[*]}"
echo -e "${BLUE}Top results:${NC} $SHOW_TOP"
echo -e "${CYAN}$(printf '%.0s=' {1..50})${NC}"

# Function to check if hour is in any of the specified ranges
is_hour_in_range() {
    local hour=$1
    for range in "${TIME_RANGES[@]}"; do
        local start=$(echo "$range" | cut -d'-' -f1)
        local end=$(echo "$range" | cut -d'-' -f2)
        if [[ "$hour" -ge "$start" ]] && [[ "$hour" -le "$end" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to check if URL matches any pattern
url_matches_pattern() {
    local url=$1
    for pattern in "${URL_PATTERNS[@]}"; do
        if echo "$url" | grep -q "$pattern"; then
            return 0
        fi
    done
    return 1
}

# Function to extract hour from timestamp
extract_hour() {
    local timestamp="$1"
    # Extract hour from timestamp format: 2025-09-017T00:17:25.868+0100
    echo "$timestamp" | grep -oE 'T([0-9]{2})' | sed 's/T//'
}

# Temporary files
TEMP_FILE=$(mktemp /tmp/caapi_analysis.XXXXXX)
TEMP_FILTERED=$(mktemp /tmp/caapi_filtered.XXXXXX)
TEMP_COUNTS=$(mktemp /tmp/caapi_counts.XXXXXX)

# Function to cleanup temp files
cleanup() {
    rm -f "$TEMP_FILE" "$TEMP_FILTERED" "$TEMP_COUNTS"
    echo -e "${CYAN}Temp files cleaned up.${NC}"
}
trap cleanup EXIT

echo -e "${YELLOW}Processing log file...${NC}"

# Extract relevant data from log file
awk '
{
    # Extract timestamp (first field)
    timestamp = $1
    
    # Extract URL (look for ReqURL::https://)
    url = ""
    for (i=1; i<=NF; i++) {
        if ($i ~ /ReqURL::https?:\/\//) {
            url = $i
            sub(/ReqURL::/, "", url)
            break
        }
    }
    
    # Extract response code (look for SBRespCode::)
    status = ""
    for (i=1; i<=NF; i++) {
        if ($i ~ /SBRespCode::[0-9]+/) {
            status = $i
            sub(/SBRespCode::/, "", status)
            break
        }
    }
    
    # Extract response time (look for ElapsedTime::)
    response_time = ""
    for (i=1; i<=NF; i++) {
        if ($i ~ /ElapsedTime::[0-9]+/) {
            response_time = $i
            sub(/ElapsedTime::/, "", response_time)
            break
        }
    }
    
    # Filter for status codes 200 and 500
    if (status == 200 || status == 500) {
        print timestamp "|" url "|" status "|" response_time
    }
}' "$LOG_FILE" > "$TEMP_FILE"

TOTAL_LINES=$(wc -l < "$TEMP_FILE")
echo -e "${GREEN}Filtered $TOTAL_LINES relevant entries${NC}"

if [ "$TOTAL_LINES" -eq 0 ]; then
    echo -e "${RED}No relevant entries found. Check your log format.${NC}"
    exit 1
fi

# Apply URL and time filters
echo -e "${YELLOW}Applying filters...${NC}"

while IFS='|' read -r timestamp url status response_time; do
    if [[ -n "$timestamp" && -n "$url" && -n "$status" ]]; then
        # Extract hour from timestamp
        hour=$(extract_hour "$timestamp")
        
        # Check if URL matches any pattern and hour is in range
        if url_matches_pattern "$url" && is_hour_in_range "$hour"; then
            # Format timestamp for display (extract date and hour)
            display_time=$(echo "$timestamp" | sed 's/T\([0-9]\{2\}\):.*/\1:00/')
            echo "$display_time|$url|$status|$response_time"
        fi
    fi
done < "$TEMP_FILE" > "$TEMP_FILTERED"

FILTERED_LINES=$(wc -l < "$TEMP_FILTERED")
echo -e "${GREEN}After filtering: $FILTERED_LINES entries${NC}"

if [ "$FILTERED_LINES" -eq 0 ]; then
    echo -e "${YELLOW}No entries match the specified filters.${NC}"
    exit 0
fi

# Generate counts
sort "$TEMP_FILTERED" | uniq -c | sort -nr > "$TEMP_COUNTS"

# Display results for each URL pattern and time range combination
for pattern in "${URL_PATTERNS[@]}"; do
    for range in "${TIME_RANGES[@]}"; do
        start_hour=$(echo "$range" | cut -d'-' -f1)
        end_hour=$(echo "$range" | cut -d'-' -f2)
        
        echo -e "\n${CYAN}=== URL: $pattern === Time: ${start_hour}-${end_hour} ===${NC}"
        
        # Filter for this specific pattern and time range
        grep "$pattern" "$TEMP_COUNTS" | while read line; do
            count=$(echo $line | awk '{print $1}')
            rest=$(echo $line | cut -d' ' -f2-)
            time_cat=$(echo $rest | cut -d'|' -f1)
            url=$(echo $rest | cut -d'|' -f2)
            status=$(echo $rest | cut -d'|' -f3)
            response_time=$(echo $rest | cut -d'|' -f4)
            
            # Check if this entry is in the current time range
            entry_hour=$(echo "$time_cat" | cut -d':' -f1)
            if [[ "$entry_hour" -ge "$start_hour" ]] && [[ "$entry_hour" -le "$end_hour" ]]; then
                if [ "$status" -eq 200 ]; then
                    color="$GREEN"
                    status_text="SUCCESS"
                else
                    color="$RED"
                    status_text="ERROR"
                fi
                
                if [ ${#url} -gt 50 ]; then
                    url="${url:0:47}..."
                fi
                
                printf "%-6s %-8s ${color}%-10s${NC} %-60s %-10s %-6s\n" \
                    "$time_cat" "$status_text" "$count" "$url" "${response_time}ms" "$status"
            fi
        done | head -$SHOW_TOP
        
        # Display summary for this combination
        if [ "$SHOW_SUMMARY" = true ]; then
            total_200=$(grep "$pattern" "$TEMP_COUNTS" | grep "|200|" | awk -v start="$start_hour" -v end="$end_hour" '
            {
                hour = substr($0, index($0,"|")+1)
                hour = substr(hour, 1, index(hour,":")-1)
                hour = hour + 0
                if (hour >= start && hour <= end) {
                    sum += $1
                }
            } END {print sum}')
            
            total_500=$(grep "$pattern" "$TEMP_COUNTS" | grep "|500|" | awk -v start="$start_hour" -v end="$end_hour" '
            {
                hour = substr($0, index($0,"|")+1)
                hour = substr(hour, 1, index(hour,":")-1)
                hour = hour + 0
                if (hour >= start && hour <= end) {
                    sum += $1
                }
            } END {print sum}')
            
            total=$((total_200 + total_500))
            
            if [ $total -gt 0 ]; then
                success_rate=$(echo "scale=2; $total_200 * 100 / $total" | bc)
                echo -e "${BLUE}Summary for $pattern (${start_hour}-${end_hour}):${NC}"
                echo -e "  Total requests: $total"
                echo -e "  Success (200): ${GREEN}$total_200${NC}"
                echo -e "  Errors (500): ${RED}$total_500${NC}"
                echo -e "  Success rate: ${GREEN}$success_rate%${NC}"
            fi
        fi
    done
done

echo -e "\n${GREEN}Analysis completed successfully!${NC}"

# Example 1: Upload document between 10-11 AM
./caapi_log_analyzer_dynamic.sh -f access.log -u "uploaddocument" -t 10-11

# Example 2: Download document between 12-1 PM  
./caapi_log_analyzer_dynamic.sh -f access.log -u "downloaddocument" -t 12-13

# Multiple patterns and time ranges
./caapi_log_analyzer_dynamic.sh -f access.log -u "uploaddocument" -u "downloaddocument" -t 10-11 -t 12-13

# Show top 30 results
./caapi_log_analyzer_dynamic.sh -f access.log -u "uploaddocument" -t 10-11 -n 30

# Analyze specific API version
./caapi_log_analyzer_dynamic.sh -f access.log -u "v1/upload" -t 10-11
