#!/bin/bash

# Script: caapi_log_analyzer.sh
# Description: Analyze CAAPI logs with the specific format provided

# Default values
LOG_FILE=""
TIME_CATEGORY="hour"  # hour, day, or month
SHOW_TOP=10
SHOW_SUMMARY=true
COLOR_OUTPUT=true

# Colors for terminal output
if [ "$COLOR_OUTPUT" = true ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    PURPLE='\033[0;35m'
    NC='\033[0m' # No Color
else
    RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; PURPLE=''; NC=''
fi

# Function to display usage
usage() {
    echo "Usage: $0 -f <log_file> [-t <time_category>] [-n <top_n>] [--no-color] [--no-summary]"
    echo "  -f  Log file to analyze (required)"
    echo "  -t  Time category: hour, day, month (default: hour)"
    echo "  -n  Number of top results to show (default: 10)"
    echo "  --no-color    Disable colored output"
    echo "  --no-summary  Disable summary display"
    echo "  -h  Show this help message"
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f) LOG_FILE="$2"; shift 2 ;;
        -t) TIME_CATEGORY="$2"; shift 2 ;;
        -n) SHOW_TOP="$2"; shift 2 ;;
        --no-color) COLOR_OUTPUT=false; shift ;;
        --no-summary) SHOW_SUMMARY=false; shift ;;
        -h) usage ;;
        *) echo "Unknown option: $1"; usage ;;
    esac
done

# Validate required parameters
if [[ -z "$LOG_FILE" ]]; then
    echo -e "${RED}Error: Log file is required${NC}"
    usage
fi

if [[ "$LOG_FILE" != "-" ]] && [[ ! -f "$LOG_FILE" ]]; then
    echo -e "${RED}Error: Log file '$LOG_FILE' not found${NC}"
    exit 1
fi

if [[ ! "$TIME_CATEGORY" =~ ^(hour|day|month)$ ]]; then
    echo -e "${RED}Error: Time category must be 'hour', 'day', or 'month'${NC}"
    exit 1
fi

echo -e "${CYAN}=== CAAPI Log Analyzer ===${NC}"
if [[ "$LOG_FILE" != "-" ]]; then
    echo -e "${BLUE}Log file:${NC} $LOG_FILE"
    echo -e "${BLUE}File size:${NC} $(du -h "$LOG_FILE" 2>/dev/null | cut -f1 || echo "N/A")"
    echo -e "${BLUE}Lines:${NC} $(wc -l < "$LOG_FILE" 2>/dev/null || echo "N/A")"
fi
echo -e "${BLUE}Time category:${NC} $TIME_CATEGORY"
echo -e "${BLUE}Top results:${NC} $SHOW_TOP"
echo -e "${CYAN}$(printf '%.0s=' {1..50})${NC}"

# Function to extract timestamp category
get_time_category() {
    local timestamp="$1"
    case $TIME_CATEGORY in
        hour)
            # Extract YYYY-MM-DD HH:00 format from "2025-09-01700:17:25.868"
            echo "$timestamp" | sed 's/\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\)\([0-9]\{2\}\):[0-9]\{2\}:[0-9]\{2\}\.[0-9]\{3\}/\1 \2:00/'
            ;;
        day)
            # Extract YYYY-MM-DD format
            echo "$timestamp" | sed 's/\([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\).*/\1/'
            ;;
        month)
            # Extract YYYY-MM format
            echo "$timestamp" | sed 's/\([0-9]\{4\}-[0-9]\{2\}\).*/\1/'
            ;;
    esac
}

# Temporary files
TEMP_FILE=$(mktemp /tmp/caapi_analysis.XXXXXX)
TEMP_COUNTS=$(mktemp /tmp/caapi_counts.XXXXXX)

# Function to cleanup temp files
cleanup() {
    rm -f "$TEMP_FILE" "$TEMP_COUNTS"
    echo -e "${CYAN}Temp files cleaned up.${NC}"
}
trap cleanup EXIT

echo -e "${YELLOW}Processing log file...${NC}"

# Extract relevant data from the specific log format
if [[ "$LOG_FILE" == "-" ]]; then
    # Read from stdin
    cat - | awk '
    {
        # Extract timestamp (first field)
        timestamp = $1
        
        # Extract URL (look for ReqURL: :https://)
        url = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /ReqURL::https?:\/\//) {
                url = $i
                sub(/ReqURL::/, "", url)
                break
            }
        }
        
        # Extract response code (look for SBRespCode: :)
        status = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /SBRespCode::[0-9]+/) {
                status = $i
                sub(/SBRespCode::/, "", status)
                break
            }
        }
        
        # Extract response time (look for ElapsedTime::)
        response_time = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /ElapsedTime::[0-9]+/) {
                response_time = $i
                sub(/ElapsedTime::/, "", response_time)
                break
            }
        }
        
        # Filter for status codes 200 and 500
        if (status == 200 || status == 500) {
            print timestamp "|" url "|" status "|" response_time
        }
    }' > "$TEMP_FILE"
else
    # Read from file
    awk '
    {
        # Extract timestamp (first field)
        timestamp = $1
        
        # Extract URL (look for ReqURL: :https://)
        url = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /ReqURL::https?:\/\//) {
                url = $i
                sub(/ReqURL::/, "", url)
                break
            }
        }
        
        # Extract response code (look for SBRespCode: :)
        status = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /SBRespCode::[0-9]+/) {
                status = $i
                sub(/SBRespCode::/, "", status)
                break
            }
        }
        
        # Extract response time (look for ElapsedTime::)
        response_time = ""
        for (i=1; i<=NF; i++) {
            if ($i ~ /ElapsedTime::[0-9]+/) {
                response_time = $i
                sub(/ElapsedTime::/, "", response_time)
                break
            }
        }
        
        # Filter for status codes 200 and 500
        if (status == 200 || status == 500) {
            print timestamp "|" url "|" status "|" response_time
        }
    }' "$LOG_FILE" > "$TEMP_FILE"
fi

TOTAL_LINES=$(wc -l < "$TEMP_FILE" 2>/dev/null || echo "0")
echo -e "${GREEN}Filtered $TOTAL_LINES relevant entries${NC}"

if [ "$TOTAL_LINES" -eq 0 ]; then
    echo -e "${RED}No relevant entries found. Check your log format.${NC}"
    exit 1
fi

# Process and count
echo -e "${YELLOW}Generating statistics...${NC}"

while IFS='|' read -r timestamp url status response_time; do
    if [[ -n "$timestamp" && -n "$url" && -n "$status" ]]; then
        time_cat=$(get_time_category "$timestamp")
        echo "$time_cat|$url|$status|$response_time"
    fi
done < "$TEMP_FILE" | sort | uniq -c | sort -nr > "$TEMP_COUNTS"

# Display results
echo -e "\n${CYAN}=== TOP $SHOW_TOP API ENDPOINTS WITH 500 ERRORS ===${NC}"
printf "%-20s %-50s %-10s %-12s\n" "Time Category" "API URI" "Count" "Avg Time(ms)"
printf "%-20s %-50s %-10s %-12s\n" "-------------------" "--------------------------------------------------" "----------" "------------"

grep "|500|" "$TEMP_COUNTS" | head -$SHOW_TOP | while read line; do
    count=$(echo $line | awk '{print $1}')
    rest=$(echo $line | cut -d' ' -f2-)
    time_cat=$(echo $rest | cut -d'|' -f1)
    url=$(echo $rest | cut -d'|' -f2)
    response_time=$(echo $rest | cut -d'|' -f4)
    
    # Calculate average response time
    if [ -n "$response_time" ] && [ "$response_time" -gt 0 ]; then
        avg_time=$response_time
    else
        avg_time="N/A"
    fi
    
    if [ ${#url} -gt 48 ]; then
        url="${url:0:45}..."
    fi
    
    printf "%-20s %-50s ${RED}%-10s${NC} %-12s\n" "$time_cat" "$url" "$count" "$avg_time"
done

echo -e "\n${CYAN}=== TOP $SHOW_TOP API ENDPOINTS WITH 200 SUCCESS ===${NC}"
printf "%-20s %-50s %-10s %-12s\n" "Time Category" "API URI" "Count" "Avg Time(ms)"
printf "%-20s %-50s %-10s %-12s\n" "-------------------" "--------------------------------------------------" "----------" "------------"

grep "|200|" "$TEMP_COUNTS" | head -$SHOW_TOP | while read line; do
    count=$(echo $line | awk '{print $1}')
    rest=$(echo $line | cut -d' ' -f2-)
    time_cat=$(echo $rest | cut -d'|' -f1)
    url=$(echo $rest | cut -d'|' -f2)
    response_time=$(echo $rest | cut -d'|' -f4)
    
    # Calculate average response time
    if [ -n "$response_time" ] && [ "$response_time" -gt 0 ]; then
        avg_time=$response_time
    else
        avg_time="N/A"
    fi
    
    if [ ${#url} -gt 48 ]; then
        url="${url:0:45}..."
    fi
    
    printf "%-20s %-50s ${GREEN}%-10s${NC} %-12s\n" "$time_cat" "$url" "$count" "$avg_time"
done

# Summary statistics
if [ "$SHOW_SUMMARY" = true ]; then
    echo -e "\n${CYAN}=== SUMMARY STATISTICS ===${NC}"
    
    total_200=$(grep -c "|200|" "$TEMP_COUNTS" 2>/dev/null || echo "0")
    total_500=$(grep -c "|500|" "$TEMP_COUNTS" 2>/dev/null || echo "0")
    total_entries=$((total_200 + total_500))
    
    if [ $total_entries -gt 0 ]; then
        success_rate=$(echo "scale=2; $total_200 * 100 / $total_entries" | bc)
        error_rate=$(echo "scale=2; $total_500 * 100 / $total_entries" | bc)
    else
        success_rate=0
        error_rate=0
    fi
    
    # Calculate average response times
    avg_200_time=$(grep "|200|" "$TEMP_COUNTS" | awk -F'|' '{sum += $4; count++} END {if (count>0) printf "%.2f", sum/count; else print "N/A"}' $TEMP_COUNTS)
    avg_500_time=$(grep "|500|" "$TEMP_COUNTS" | awk -F'|' '{sum += $4; count++} END {if (count>0) printf "%.2f", sum/count; else print "N/A"}' $TEMP_COUNTS)
    
    echo -e "${BLUE}Total 200 responses:${NC} $total_200"
    echo -e "${BLUE}Total 500 errors:${NC} $total_500"
    echo -e "${BLUE}Total entries analyzed:${NC} $total_entries"
    echo -e "${BLUE}Success rate:${NC} ${GREEN}$success_rate%${NC}"
    echo -e "${BLUE}Error rate:${NC} ${RED}$error_rate%${NC}"
    echo -e "${BLUE}Avg response time (200):${NC} ${GREEN}${avg_200_time}ms${NC}"
    echo -e "${BLUE}Avg response time (500):${NC} ${RED}${avg_500_time}ms${NC}"
    
    # Show time distribution
    echo -e "\n${CYAN}=== TIME DISTRIBUTION (Top 5) ===${NC}"
    cut -d'|' -f1 "$TEMP_FILE" | while read timestamp; do
        get_time_category "$timestamp"
    done | sort | uniq -c | sort -nr | head -5 | \
    while read count time; do
        echo -e "${BLUE}$time:${NC} $count requests"
    done
fi

echo -e "\n${GREEN}Analysis completed successfully!${NC}"
